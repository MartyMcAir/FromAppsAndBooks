package b_BigTusks.ConsoleSpaceInvaders_2515;

public class Tmp {
    // Space (2)    //У нас будут бомбы и ракеты.
    // Значит нам нужны классы Bomb(бомба) и Rocket(ракета).
    // У наших объектов будет много общего. //Они будут перемещаться по космосу и отрисовываться.
    // Значит у них у всех будут координаты и размер. //А еще методы move() - для перемещения и draw() для отрисовки.
    // один базовый класс для всех объектов.   //Пусть это будет класс BaseObject.
    // А классы Ufo, SpaceShip, Rocket, Bomb от него наследуются.
    // Еще нам понадобится класс Canvas.   // Он будет ответственным за "отрисовку" объектов.

    // Space (4)   //Правильно - методов run() и draw().
    //run управляет всей логикой игры, если ты помнишь.
    //А draw отвечает за отрисовку очередного "кадра".

    // Space (5)   //Теперь перейдем к классу BaseObject.
    //Во-первых. Для простоты, считать все объекты у нас в космосе круглыми.
    //Нет, отрисовывать их мы будем фигурными, как и раньше.
    //А вот при расчетах их взаимодействия исходить из того, что они круглые.   //Так - гораздо проще.
    //Во-вторых. Пусть координаты объектов и радиус будут вещественными числами.
    //Это придаст плавность движениям и точность всем вычислениям.
    //А при отрисовке мы будем их округлять.

    // _!!!_ Space (6)  //Классу BaseObject нужны еще методы. draw() и move().
    // СКОПИПАСТИЛ т.к. постоянно забывают эту логику гипотенуз с квадратами.. (и саму логику в проге)
    // сам постепенно будут изучать, но позже.. (now не когда)
    //Классы-наследники должны будут переопределить их у себя и реализовать необходимую функциональность.
    //Еще добавь метод die() - объект умирает (isAlive=false)
    //А еще нам нужно будет определять попала бомба в корабль или ракета в НЛО. isIntersect(BaseObject o)
    //Он будет определять - "пересеклись" объекты или нет. Если пересеклись - возвращать true, если нет - false.
    //Т.к. объекты мы условно считаем кругами, то предлагаю такую формулу взаимодействия:
    //eсли центр круга одного объекта попал в круг другого, то будем считать, что они столкнулись.
    //дистанция_между_объектами < max (радиус_первого_объекта, радиус_второго_объекта).

    // Space (8)  Canvas?  //Мы будем рисовать на нем (в его матрице).
    // ___ !!! ___ --- НЕПОНЯЛ ПОЧЕМУ МАССИВ char, и что значит занести char в матрицу!?

    //public void setPoint(double x, double y, char c), //Первый метод - setPoint будет "ставить точку в координатах x,y цветом c".
    //а) округлить x и y до целых чисел, //б) занести в matrix[y][x] значение с,
    //в) ничего не делать, если x<0 или y<0 или y>=matrix.length или x>=matrix[0].length.
    //public void drawMatrix(double x, double y, int[][] matrix, char c).
    //Второй метод - drawMatrix копирует переданную ему картинку (матрицу) в матрицу Canvas.
    //И не просто копирует, а начиная с координат x, y.
    //а) с помощью двух вложенных циклов пройтись по всем ячейкам переданной картинки,
    //б) если значение ячейки matrix[i][j] не равно 0, то покрасить в матрице объекта Canvas точку (x+j, y+i) в цвет c:
    //setPoint(x+j, y+i, c)

    // https://javarush.ru/tasks/com.javarush.task.task25.task2515.big08#discussion
    // Мозг тупит, отказывается воспринимать, что в двумерном массиве matrix[h][w] h - высота и соответственно
    // координата y, а w - это ширина и соответственно координата x. Все время пытается думать наоборот (matrix[x][y]).
    // А я никак не могу понять, что за странные дела у них происходят с осями.
    //б) если значение ячейки matrix[i][j] не равно 0, то покрасить в матрице объекта Canvas точку (x+j, y+i) в цвет c:
    //setPoint(x+j, y+i, c)
    //
    //Почему тут горизонталь и вертикаль меняются местами? И так постоянно.
    //В прошлой задаче у них вообще холст менял ориентацию трижды.
    //Видимо, авторы сами путаются.
    // А я никак не могу понять, что за странные дела у них происходят с осями.
    //б) если значение ячейки matrix[i][j] не равно 0, то покрасить в матрице объекта Canvas точку (x+j, y+i) в цвет c:
    //setPoint(x+j, y+i, c)
    //
    //Почему тут горизонталь и вертикаль меняются местами? И так постоянно.
    //В прошлой задаче у них вообще холст менял ориентацию трижды.
    //Видимо, авторы сами путаются.

    // Space (9)  ___ !!! ___ --- Опять непонял логики зачем эти +2!? _  copyPast
    //Еще Canvas понадобится два метода, напиши их.
    //а) метод clear();
    //Этот метод будет очищать матрицу, чтобы на ней снова можно было рисовать.
    //Например заменить все символы матрицы на пробелы.
    //
    //б) метод print();

    // Space (10) _ Cделал, но логике опять же не понял.. (что происходит для чего это?)
    //Теперь напишем класс Bomb. Тут все просто.

    // Space (13)   //Теперь перейдем к методам draw, move.   //В методе move() надо:
    //а) увеличить x на dx;
    //б) проверить, не вылез ли корабль за границы космоса [0, Space.game.getWidth()]. Используй метод checkBorders.
    //Учти, что ширина корабля равна двум его радиусам.

    // Space (14) _ coy Past __ (вот 2048 понимал, а тут неоч!( )
    //Теперь напиши класс Ufo.
    //Он чуть сложнее класса Bomb и проще SpaceShip.

    //   Space (16) //И еще немного:  //Напиши метод createUfo(): _ copyPast
    // removeDead(): bombs.removeIf(v -> !v.isAlive());

}